---
title: 从浏览器地址栏输入url开始
---
目录：
[[toc]]

### 要点总结

1. DNS解析：将域名解析成IP地址
2. 建立TCP连接：TCP三次握手
3. TLS协商（仅HTTPS请求）
4. 发送HTTP请求
5. 服务器处理请求并返回HTTP报文
6. 浏览器解析渲染页面
7. 断开连接：TCP四次挥手

### 详细解析

1. url的定义（Uniform Resource Locator 统一资源定位符），用于定位互联网上的资源，以下面这个为例：

    ```s
      HTTP://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#SomewhereInTheDocument
    ```

    * `HTTP`是协议。它表明了浏览器必须使用哪一种协议，通常为HTTP协议和HTTPS协议。[HTTP和HTTPS的区别](#HTTP和HTTPS的区别)
    web浏览器中常见的是这种，浏览器也知道如何处理其他协议，比如：`mailto:(打开邮件客户端)`或者`ftp:(处理文件传输)`

    * `www.example.com`是域名。它表明正在请求哪个web服务器。或者可以直接使用IP address。DNS（DomainName System 域名系统）的作用就是将域名映射到服务对应的ip地址。

    * `80`是端口。它表示用于访问web服务器伤的资源的技术“门”。如果web服务没有特别指出端口，则使用HTTP协议的默认端口（HTTP：80，HTTPS：443）。

    * `/path/to/myfile.html`是网络服务器上资源的路径。在web的早起阶段，这种路径表示web服务器上物理文件的位置。但是如今，它主要是由没有任何物理实现的web服务器处理的抽象。例如单页面应用的路径并不能表示物理位置，而是运行js代码加载的相对应的资源。

    * `?key1=value1&key2=value2`是提供给网络服务器的额外参数。在返回资源之前，web服务器可以使用这些参数来执行额外的操作。

    * `#SomewhereInTheDocument`是资源身的另一部分的锚点，表示资源中的一种“书签“。比如：在html文档上，浏览器将滚动到定义锚点的位置；在视屏音频文档上，浏览器将尝试转到锚点所代表的时间。且：#后面的内容（片段标志符）不会被发送到请求的服务器,以下图为例，刷新该地址，HTTP请求中并不会将锚点后的内容向服务器进行请求。

    ![url](/images/url.png)
    ![HTTP请求](/images/HTTP.png)

2. 域名与DNS(DomianName System)

    * 域名为互联网可用的网页服务器提供了方便人类理解的地址。当你在注册商那注册了一个域名，几个小时内，所有的DNS服务器都会收到你的DNS信息。我们在访问一个域名的时候，通常会向网络服务商的最底层的DNS服务器查询域名，如果没有查询到，就会去上一级的服务器查询，一直到从顶级服务器中查询到你的域名为止。并且这个结果，会缓存在底层的DNS服务器里。

    * DNS请求的工作流程：

        ```s
        1. 在你的浏览器地址栏输入baidu.com
        2. 浏览器询问计算机是否已经已经识别此域名所确定的IP地址（使用本地DNS缓存）。
           如果是的话，这个域名就会被转换为IP地址，然后浏览器与网络服务器交换内容，结束域名解析流程。
        3. 如果你的计算机不知道baidu.com域名背后的IP,它会询问一个DNS服务器，这个服务器的功能就是告诉你的计算机已经注册的域名所匹配的IP.
        4. 然后计算机就知道了要请求的IP地址，你的浏览器能够与网络服务器建立连接
        ```

3. TCP握手

    握手过程：

    ```s
    1. 客户端发送一个带SYN=1，Seq=X的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
    2. 服务器收到这个数据包之后，发回一个带SYN=1,ACK=X+1,Seq=Y的响应包，传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受请求了，你可以发送了）
    3. 客户端再回传一个带ACK=Y+1,Seq=Z的数据包，代表“握手结束”，连接建立成功，开始数据传输（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）
    ```

    三次握手的原因：

    ```s
    为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。
    ```

4. TLS协商。为了在HTTPS上建立安全连接，我们需要进行TLS协商。它会决定服务端和客户端进行通信加密使用的秘钥，传播公钥时使用的是非对称加密，然后传输数据时，使用对称加密。

5. 在浏览器和服务器之间，有许多的计算机和其它设备转发了HTTP消息，比如你的路由器、网线。这些主要出现在传输层、网络层和物理层上，所以你的宽带网速，也很大程度上的影响了你网页的加载速度。但是在这中间，我们可能会通过代理，去向服务器请求我们需要的资源。目前适用范围最广的代理是：nginx。

    nginx代理服务器的主要作用：

    * 缓存，但是当cache control: privite时，不允许代理服务器进行缓存
    * 过滤（像反病毒扫描，家长控制）
    * 负载均衡（让多个服务器服务不同的请求）
    * 认证（对不同资源进行权限管理）
    * 日志记录（允许存储历史信息）

6. HTTP请求

    一旦我们建立了到web服务器的连接，浏览器就代表用户发送了一个初始的HTTP GET请求，对于网站来说，这个请求通常是一个HTML文件。一旦服务器收到请求，它将使用相应的响应头和html的内容进行回复。

7. TCP慢开始/14kb规则。 第一个响应包的大小是14kb。这是慢开始的一部分，慢开始是一种均衡网络连接速度的算法，慢开始逐渐增加发送数据的数量直到达到网络的最大带宽。在收到初始包之后，服务器会将下一个包的大小加倍到28kb，然后后续包依次是前一个包大小的2倍，直到到达预定的阈值或者遇到堵塞。

8. 一旦浏览器收到数据的第一块，它就可以开始解析收到的信息。这就是为什么在前14kb中包含浏览器开始渲染页面所需的所有内容，至少包含页面模板（第一次渲染所需的css和html）对于web性能优化来说至关重要。

9. 浏览器解析过程：

    * 处理HTML标签并构造DOM树。良好的文档格式，有利于加快dom树的解析速度。dom节点的数量越多，构建dom树需要的时间就越长。DOM树解析的过程是一个深度优先遍历，会先构建初当前节点的所有字节点，再构建下一个兄弟节点。

    * 当解析器发现非阻塞资源例如图片或者css文件时，解析也可以继续进行。但是对于`<script>`标签(特别说没有async或者dfer属性的script标签),会阻塞渲染并停止HTML的解析。可以使用`<link rel="preload" href="main.js" as="script">` link的rel属性配置预加载，这样在随后的页面渲染中，一旦需要使用到它们，它们就立刻可用，不需要停止html解析

    * 接下来是处理css并构建CSSOM树。（尽量避免使用后代选择器，因为css树计算时，先匹配后代，再对父元素进行匹配，相对于具名类选择器来说，性能非常的差）

    * 当css被解析并创建COSSOM时，js文件被解释、编译和执行。脚本被解析为抽象语法树（Abstract Syntax Tree）.一些浏览器引擎使用AST并将其传递到解释器中，输出在主线程执行的字节码。这就是js编译的过程。

    * 浏览器还会构建辅助设备用户分析和解释内容的辅助功能树-可访问性对象模型（AOM）类似DOM的语义版本，这也是为什么我们在开发网页的时候，推荐使用语义化的标签，更加有利于构建清晰的可访问对象。在构建AOM之前，屏幕阅读器无法访问内容

    * dom树和cssom树构造完毕以后，浏览器会将DOM树和cssom树组合成一个Render树，计算render树从dom树的根开始构建，遍历每个可见节点。（display:none的节点不会出现在render树上，visibility:hidden的节点会出现在render树上,且会占用空间）。render树会将所有相关样式匹配到dom树中的每个可见节点，并根据css的层级确定每个节点的样式。

    * 接下来是在渲染树上运行布局以计算每个节点的几何体。第一次确定节点的大小和位置称为布局。随后对节点的大小和位置的重新计算称为回流。为了确定每个DOM节点的确切大小和位置。浏览器会从渲染树的根开始遍历，因此布局和回流是十分耗费性能的。

    * 最后一步是将各个节点绘制到屏幕上。在绘制阶段，浏览器将把元素的每个可视化部分绘制到屏幕上。绘制可以将布局树中的元素分解为多个层，将内容提升到GPU上的层，可以提高绘制和重绘的性能。层的确可以提高性能，但是它以内存管理为代价。所以不应该过度使用。

    * 当文档的各个部分以不同的层绘制，互相重叠时，必须进行合成，以确保它们以正确的顺序绘制到屏幕上。

    * 一旦主线绘制页面完成，如果主线程正在解析、编译和执行js，则此时页面还是无法及时响应用户交互，当相关js执行完毕，页面进入可交互状态。

    * 到此，一个完整的页面加载完毕。为了不需要每请求一个HTTP就要建立一个tcp连接，HTTP1.1提出了HTTP keep-alive，只要任意一段没有明确提出断开连接，则保持TCP连接状态。

    * 在HTTP1.0时期，HTTP请求完毕，tcp连接关闭。开始四次挥手：

        * 第一次挥手，由浏览器发起，告诉服务器：我请求报文发送完了，你准备关闭吧
        * 第二次挥手，由服务器发起，告诉浏览器：我请求报文接收完了，我准备关闭了，你也准备吧
        * 第三次挥手，由服务器发起，告诉浏览器：我响应报文发送完了，你准备关闭吧
        * 第四次挥手，由浏览器发起，告诉服务器：我响应报文接收完了，我准备关闭了，你也准备吧。然后服务器收到挥手后，关闭连接。然后浏览器还等待一定时间未收到回复，则正常关闭。

### HTTP状态码

|状态码|分类|描述
|-----|:----------:|:-------------------|
| 100 Continue |信息响应|客户端应继续其请求, 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分|
|101 Switching Protocols| 信息响应 | 切换协议。表示服务器回应客户端升级协议的请求（Upgrade请求头），正在切换协议。且会发送一个Upgrade响应头来表明正在切换过去的协议。在使用WebSokects时会用到协议切换。
|103 Early Hints| 信息响应| 一般和Link header 一起使用，用来允许用户在服务器还在准备响应数据的时候，预加载一些资源|
|200 OK|成功响应| 成功的含义取决于HTTP Methods:<br>`GET: 资源一杯提取并正在消息正文中传输`<br>`HEAD:实体标题头位于消息正文中`<br>`POST:描述动作结果的资源在消息体中传输`<br>`TRACE:消息正文包含服务器收到的请求消息`|
|201 created|成功响应|请求已成功，并因此创建了一个新的资源。通常作用于POST请求或者某些PUT请求之后返回的响应|
|202 Accepted|成功响应|表示该请求已经被接收但尚未起作用。202状态码适合异步任务或者处理时间比教程的请求，避免HTTP连接一直占用、超时。（MQ异步处理披任务，客户端定时轮训结果）|
|203 Non-Authoritative Infomation|成功响应| 非权威内容，服务器成功处理了这个请求，但是代理服务器对内容做出了一些改动。代理服务器通过这个状态码告诉用户，成功获取内容，但是这部份内容和原始服务器返回的内容可能不完全一致|
|204 No Content|成功响应|服务器成功处理了请求，但不需要返回任何实体内容。如果客户端是浏览器的话，那么浏览器应保留了发送该请求的页面，而不产生任何文档视图上的变化。|
|205 Reset Content|成功响应|服务器成功处理了请求,且没有返回任何内容。该请求要求请求者重置文档视图。该响应主要是被用于接收用户输入后，立即重置表单|
|206 Partial Content|成功响应|部分请求成功|
|300 Multiple Choice|重定向响应|多项选择，客户端请求了实际上指向多个资源的url，这个状态码是和一个选项列表一起返回的，用户可以选择想要的选项|
|301 Moved Permanently|重定向响应|被请求的资源已永久移动到新位置，除非额外指定，否则响应可缓存|
|302 Found|重定向响应|请求的资源现在临时从不同的url响应请求。指定Cache-Control或Expires后，才可缓存|
|303 See Other|重定向响应|对应当前请求的响应可以在另一个URL上被找到，且客户端应采用Get方法去访问该资源|
|304 Not Modified|重定向响应|服务器验证该请求请求的内容本地的缓存是有效的，就会返回此状态码，让客户端使用缓存的内容|
|305 Use Proxy|重定向响应|使用代理。所请求的资源必须通过代理访问，代理的地址会出现在Location里。只有原始服务器才能建立305响应|
|307 Temporary Redirect|重定向响应|临时重定向响应，指定Cache-Control或Expires后，才可缓存|
|308 Permanent Redirect|重定向响应|这意味着资源永久位于由Location:HTTP Response 指定的另一个URL。类似301.但是用户代理不能更改所使用的HTTP Methods|
|400 Bad Request|客户端响应|1.语义有误，当前请求无法被服务器理解 2. 请求参数有误|
|401 Unauthorized|客户端响应|当前请求需要用户的身份认证。该响应必须包含一个适用于被请求资源的WWW-Authorization 请求头用以询问用户信息|
|403 Forbidden|客户端响应|服务器已经理解请求，但是拒绝执行它。有时通过nginx代理的域名访问时，浏览器会返回403页面，是因为autoindex为off，不会自动创建索引|
|404 Not Found|客户端响应|请求失败，服务器上没有找到该请求需要的资源。|
|405 Method Not Allowed|客户端响应|请求中指定的请求方法不能被用户请求响应的资源，因为PUT、DELETE方法会对服务器上的资源进行写操作，因此大部分的网页服务器都不支持或者默认配置下不允许上述请求方法，均会返回405错误|
|406 Not Acceptable|客户端响应|请求的资源的内容特性无法满足请求头中的条件，因为无法生成响应实体|
|408 Request Timeout|客户端响应|客户端请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送|
|429 Too Many Requests|客户端响应|用户在给定的时间内发送了太多请求。（用于限制请求速率）|
|500 Internal Server Error|服务端响应|服务器遇到了不知道如何处理的情况|
|501 Not Implemented|服务端响应|服务器不支持客户端发送的HTTP Method，比如CONNECT方法，只在HTTP1.1中被定义，但是你的web服务器版本比较旧则会触发501错误|
|502 Bad Gateway|服务端响应|错误的网关，作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了一个无效的响应|
|503 Service Unavailable| 服务端响应|服务器没有准备好处理请求。常见原因时服务器因维护或者重载而停机|
|504 Gateway Timeout|服务端响应|当服务器作为网关，不能及时得到响应时返回此错误代码|
|505 HTTP Version Not Support|服务端响应|服务器不支持请求中所使用的HTTP协议版本|

### http状态码301和302的同与不同

### HTTP Methods

### HTTP和HTTPS的区别

### HTTP缓存

### HTTP1.0 到 HTTP1.1 到HTTP2.0

### link preload 的好处

* 更加精确的优化资源加载优先级
* 匹配未来的加载需求，在适当的情况下，重复利用同一资源
* 为资源应用正确的内容安全策略
* 为资源设置正确的Accept请求头

### GPU&web性能优化

### 如何减少页面的回流

* 事先设定好图片标签的大小，避免在图片加载完成后，获得图片大小触发回流

### requestAnimationFrame 和 setTimeout区别

  [requestAnimationFrame](HTTPS://juejin.im/entry/6844903600557129736)

### 重绘与回流
